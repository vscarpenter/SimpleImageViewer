import Foundation

/// Generates hierarchical, searchable smart tags for images
/// Categorizes tags by: Content (WHAT), Location (WHERE), Time (WHEN), People (WHO), Style, and Use Case
final class SmartTagGenerator {

    // MARK: - Public Interface

    func generateSmartTags(
        classifications: [ClassificationResult],
        objects: [DetectedObject],
        scenes: [SceneClassification],
        text: [RecognizedText],
        colors: [DominantColor],
        landmarks: [DetectedLandmark],
        recognizedPeople: [RecognizedPerson],
        purpose: ImagePurpose
    ) -> [SmartTag] {
        var tags: [SmartTag] = []

        // Generate tags by category
        tags.append(contentsOf: generateContentTags(classifications: classifications, objects: objects, purpose: purpose))
        tags.append(contentsOf: generateLocationTags(scenes: scenes, landmarks: landmarks, purpose: purpose))
        tags.append(contentsOf: generateTimeTags(colors: colors, scenes: scenes))
        tags.append(contentsOf: generatePeopleTags(objects: objects, recognizedPeople: recognizedPeople))
        tags.append(contentsOf: generateStyleTags(colors: colors, purpose: purpose))
        tags.append(contentsOf: generateUseCaseTags(purpose: purpose, objects: objects))

        // Remove duplicates and return top 12
        return deduplicateAndLimit(tags, limit: 12)
    }

    // MARK: - Content Tags (WHAT)

    private func generateContentTags(
        classifications: [ClassificationResult],
        objects: [DetectedObject],
        purpose: ImagePurpose
    ) -> [SmartTag] {
        var tags: [SmartTag] = []

        // Add purpose-specific tag
        let purposeTag = purposeToTag(purpose)
        tags.append(SmartTag(name: purposeTag, category: .content, confidence: 0.95, isAutoGenerated: true))

        // Add top objects
        for object in objects.prefix(3) {
            let name = object.identifier.replacingOccurrences(of: "_", with: " ").capitalized
            tags.append(SmartTag(name: name, category: .content, confidence: Double(object.confidence), isAutoGenerated: true))
        }

        // Add top classifications (skip generic terms)
        for classification in classifications.prefix(3) {
            if !AIAnalysisConstants.isGeneric(classification.identifier) {
                let name = classification.identifier.replacingOccurrences(of: "_", with: " ").capitalized
                tags.append(SmartTag(name: name, category: .content, confidence: Double(classification.confidence), isAutoGenerated: true))
            }
        }

        return tags
    }

    // MARK: - Location Tags (WHERE)

    private func generateLocationTags(
        scenes: [SceneClassification],
        landmarks: [DetectedLandmark],
        purpose: ImagePurpose
    ) -> [SmartTag] {
        var tags: [SmartTag] = []

        // Add landmarks
        for landmark in landmarks.prefix(2) {
            tags.append(SmartTag(name: landmark.name, category: .location, confidence: landmark.confidence, isAutoGenerated: true))
        }

        // Add scene-based location tags
        for scene in scenes.prefix(2) {
            let id = scene.identifier.lowercased()

            if id.contains("outdoor") {
                tags.append(SmartTag(name: "Outdoor", category: .location, confidence: Double(scene.confidence), isAutoGenerated: true))
            } else if id.contains("indoor") {
                tags.append(SmartTag(name: "Indoor", category: .location, confidence: Double(scene.confidence), isAutoGenerated: true))
            }

            if id.contains("nature") || id.contains("forest") || id.contains("mountain") {
                tags.append(SmartTag(name: "Nature", category: .location, confidence: Double(scene.confidence), isAutoGenerated: true))
            } else if id.contains("urban") || id.contains("city") {
                tags.append(SmartTag(name: "Urban", category: .location, confidence: Double(scene.confidence), isAutoGenerated: true))
            }
        }

        return tags
    }

    // MARK: - Time Tags (WHEN)

    private func generateTimeTags(
        colors: [DominantColor],
        scenes: [SceneClassification]
    ) -> [SmartTag] {
        var tags: [SmartTag] = []

        guard let dominantColor = colors.first else {
            return tags
        }

        let rgb = dominantColor.color.usingColorSpace(.deviceRGB) ?? dominantColor.color
        let brightness = rgb.brightnessComponent

        // Time of day based on brightness
        if brightness > 0.7 {
            tags.append(SmartTag(name: "Daytime", category: .time, confidence: 0.7, isAutoGenerated: true))
        } else if brightness < 0.3 {
            tags.append(SmartTag(name: "Night", category: .time, confidence: 0.7, isAutoGenerated: true))
        }

        // Lighting conditions
        if scenes.contains(where: { $0.identifier.lowercased().contains("sunset") }) {
            tags.append(SmartTag(name: "Sunset", category: .time, confidence: 0.8, isAutoGenerated: true))
        } else if scenes.contains(where: { $0.identifier.lowercased().contains("sunrise") }) {
            tags.append(SmartTag(name: "Sunrise", category: .time, confidence: 0.8, isAutoGenerated: true))
        }

        return tags
    }

    // MARK: - People Tags (WHO)

    private func generatePeopleTags(
        objects: [DetectedObject],
        recognizedPeople: [RecognizedPerson]
    ) -> [SmartTag] {
        var tags: [SmartTag] = []

        // Add recognized people
        for person in recognizedPeople {
            tags.append(SmartTag(name: person.name, category: .people, confidence: person.confidence, isAutoGenerated: true))
        }

        // Count people
        let peopleCount = objects.filter { $0.identifier.lowercased().contains("person") }.count
        if peopleCount == 1 {
            tags.append(SmartTag(name: "Single Person", category: .people, confidence: 0.9, isAutoGenerated: true))
        } else if peopleCount > 1 {
            tags.append(SmartTag(name: "Group", category: .people, confidence: 0.9, isAutoGenerated: true))
        }

        return tags
    }

    // MARK: - Style Tags

    private func generateStyleTags(
        colors: [DominantColor],
        purpose: ImagePurpose
    ) -> [SmartTag] {
        var tags: [SmartTag] = []

        guard !colors.isEmpty else {
            return tags
        }

        // Color-based style tags
        let avgSaturation = calculateAverageSaturation(colors)
        let avgBrightness = calculateAverageBrightness(colors)

        if avgSaturation > 0.6 {
            tags.append(SmartTag(name: "Vibrant", category: .style, confidence: 0.8, isAutoGenerated: true))
        } else if avgSaturation < 0.2 {
            tags.append(SmartTag(name: "Muted", category: .style, confidence: 0.8, isAutoGenerated: true))
        }

        if avgBrightness > 0.7 {
            tags.append(SmartTag(name: "Bright", category: .style, confidence: 0.8, isAutoGenerated: true))
        } else if avgBrightness < 0.3 {
            tags.append(SmartTag(name: "Dark", category: .style, confidence: 0.8, isAutoGenerated: true))
        }

        // Purpose-based style
        if purpose == .portrait {
            tags.append(SmartTag(name: "Professional", category: .style, confidence: 0.75, isAutoGenerated: true))
        }

        return tags
    }

    // MARK: - Use Case Tags

    private func generateUseCaseTags(
        purpose: ImagePurpose,
        objects: [DetectedObject]
    ) -> [SmartTag] {
        var tags: [SmartTag] = []

        switch purpose {
        case .portrait:
            tags.append(SmartTag(name: "Social Media", category: .event, confidence: 0.8, isAutoGenerated: true))
            tags.append(SmartTag(name: "Profile Picture", category: .event, confidence: 0.75, isAutoGenerated: true))

        case .landscape:
            tags.append(SmartTag(name: "Wallpaper", category: .event, confidence: 0.8, isAutoGenerated: true))
            tags.append(SmartTag(name: "Travel", category: .event, confidence: 0.75, isAutoGenerated: true))

        case .food:
            tags.append(SmartTag(name: "Recipe", category: .event, confidence: 0.8, isAutoGenerated: true))
            tags.append(SmartTag(name: "Menu", category: .event, confidence: 0.7, isAutoGenerated: true))

        case .document, .screenshot:
            tags.append(SmartTag(name: "Reference", category: .event, confidence: 0.85, isAutoGenerated: true))
            tags.append(SmartTag(name: "Documentation", category: .event, confidence: 0.8, isAutoGenerated: true))

        case .productPhoto:
            tags.append(SmartTag(name: "E-commerce", category: .event, confidence: 0.85, isAutoGenerated: true))

        default:
            break
        }

        return tags
    }

    // MARK: - Helper Methods

    private func purposeToTag(_ purpose: ImagePurpose) -> String {
        switch purpose {
        case .portrait: return "Portrait"
        case .groupPhoto: return "Group Photo"
        case .landscape: return "Landscape"
        case .architecture: return "Architecture"
        case .wildlife: return "Wildlife"
        case .food: return "Food"
        case .document: return "Document"
        case .screenshot: return "Screenshot"
        case .productPhoto: return "Product"
        case .general: return "General"
        }
    }

    private func calculateAverageSaturation(_ colors: [DominantColor]) -> CGFloat {
        let saturations = colors.prefix(3).map { color -> CGFloat in
            let rgb = color.color.usingColorSpace(.deviceRGB) ?? color.color
            return rgb.saturationComponent
        }
        return saturations.reduce(0, +) / CGFloat(saturations.count)
    }

    private func calculateAverageBrightness(_ colors: [DominantColor]) -> CGFloat {
        let brightnesses = colors.prefix(3).map { color -> CGFloat in
            let rgb = color.color.usingColorSpace(.deviceRGB) ?? color.color
            return rgb.brightnessComponent
        }
        return brightnesses.reduce(0, +) / CGFloat(brightnesses.count)
    }

    private func deduplicateAndLimit(_ tags: [SmartTag], limit: Int) -> [SmartTag] {
        var uniqueTags: [SmartTag] = []
        var seenNames = Set<String>()

        for tag in tags.sorted(by: { $0.confidence > $1.confidence }) {
            let lowercasedName = tag.name.lowercased()
            if !seenNames.contains(lowercasedName) {
                uniqueTags.append(tag)
                seenNames.insert(lowercasedName)

                if uniqueTags.count >= limit {
                    break
                }
            }
        }

        return uniqueTags
    }
}
