import Foundation

/// Generates hierarchical, searchable smart tags for images
/// Categorizes tags by: Content (WHAT), Location (WHERE), Time (WHEN), People (WHO), Style, and Use Case
final class SmartTagGenerator {

    // MARK: - Public Interface

    func generateSmartTags(
        classifications: [ClassificationResult],
        objects: [DetectedObject],
        scenes: [SceneClassification],
        text: [RecognizedText],
        colors: [DominantColor],
        landmarks: [DetectedLandmark],
        recognizedPeople: [RecognizedPerson],
        purpose: ImagePurpose,
        quality: ImageQuality = .unknown,
        megapixels: Double = 0,
        enhancedVision: EnhancedVisionResult? = nil
    ) -> [SmartTag] {
        var tags: [SmartTag] = []

        // Generate tags by category
        tags.append(contentsOf: generateContentTags(classifications: classifications, objects: objects, purpose: purpose))
        tags.append(contentsOf: generateLocationTags(scenes: scenes, landmarks: landmarks, purpose: purpose))
        tags.append(contentsOf: generateTimeTags(colors: colors, scenes: scenes))
        tags.append(contentsOf: generatePeopleTags(objects: objects, recognizedPeople: recognizedPeople))
        tags.append(contentsOf: generateStyleTags(colors: colors, purpose: purpose))
        tags.append(contentsOf: generateActivityTags(objects: objects, enhancedVision: enhancedVision))
        tags.append(contentsOf: generateUseCaseTags(purpose: purpose, objects: objects, quality: quality, megapixels: megapixels))

        // Remove duplicates and return top 12
        return deduplicateAndLimit(tags, limit: 12)
    }

    // MARK: - Content Tags (WHAT)

    private func generateContentTags(
        classifications: [ClassificationResult],
        objects: [DetectedObject],
        purpose: ImagePurpose
    ) -> [SmartTag] {
        var tags: [SmartTag] = []

        // Add purpose-specific tag
        let purposeTag = purposeToTag(purpose)
        tags.append(SmartTag(name: purposeTag, category: .content, confidence: 0.95, isAutoGenerated: true))

        // Add top objects
        for object in objects.prefix(3) {
            let name = object.identifier.replacingOccurrences(of: "_", with: " ").capitalized
            tags.append(SmartTag(name: name, category: .content, confidence: Double(object.confidence), isAutoGenerated: true))
        }

        // Add top classifications (skip generic terms)
        for classification in classifications.prefix(3) {
            if !AIAnalysisConstants.isGeneric(classification.identifier) {
                let name = classification.identifier.replacingOccurrences(of: "_", with: " ").capitalized
                tags.append(SmartTag(name: name, category: .content, confidence: Double(classification.confidence), isAutoGenerated: true))
            }
        }

        return tags
    }

    // MARK: - Location Tags (WHERE)

    private func generateLocationTags(
        scenes: [SceneClassification],
        landmarks: [DetectedLandmark],
        purpose: ImagePurpose
    ) -> [SmartTag] {
        var tags: [SmartTag] = []

        // Add landmarks
        for landmark in landmarks.prefix(2) {
            tags.append(SmartTag(name: landmark.name, category: .location, confidence: landmark.confidence, isAutoGenerated: true))
        }

        // Add scene-based location tags
        for scene in scenes.prefix(2) {
            let id = scene.identifier.lowercased()

            if id.contains("outdoor") {
                tags.append(SmartTag(name: "Outdoor", category: .location, confidence: Double(scene.confidence), isAutoGenerated: true))
            } else if id.contains("indoor") {
                tags.append(SmartTag(name: "Indoor", category: .location, confidence: Double(scene.confidence), isAutoGenerated: true))
            }

            if id.contains("nature") || id.contains("forest") || id.contains("mountain") {
                tags.append(SmartTag(name: "Nature", category: .location, confidence: Double(scene.confidence), isAutoGenerated: true))
            } else if id.contains("urban") || id.contains("city") {
                tags.append(SmartTag(name: "Urban", category: .location, confidence: Double(scene.confidence), isAutoGenerated: true))
            }
        }

        return tags
    }

    // MARK: - Time Tags (WHEN)

    private func generateTimeTags(
        colors: [DominantColor],
        scenes: [SceneClassification]
    ) -> [SmartTag] {
        var tags: [SmartTag] = []

        guard let dominantColor = colors.first else {
            return tags
        }

        let rgb = dominantColor.color.usingColorSpace(.deviceRGB) ?? dominantColor.color
        let brightness = rgb.brightnessComponent

        // Time of day based on brightness
        if brightness > 0.7 {
            tags.append(SmartTag(name: "Daytime", category: .time, confidence: 0.7, isAutoGenerated: true))
        } else if brightness < 0.3 {
            tags.append(SmartTag(name: "Night", category: .time, confidence: 0.7, isAutoGenerated: true))
        }

        // Lighting conditions
        if scenes.contains(where: { $0.identifier.lowercased().contains("sunset") }) {
            tags.append(SmartTag(name: "Sunset", category: .time, confidence: 0.8, isAutoGenerated: true))
        } else if scenes.contains(where: { $0.identifier.lowercased().contains("sunrise") }) {
            tags.append(SmartTag(name: "Sunrise", category: .time, confidence: 0.8, isAutoGenerated: true))
        }

        return tags
    }

    // MARK: - People Tags (WHO)

    private func generatePeopleTags(
        objects: [DetectedObject],
        recognizedPeople: [RecognizedPerson]
    ) -> [SmartTag] {
        var tags: [SmartTag] = []

        // Add recognized people
        for person in recognizedPeople {
            tags.append(SmartTag(name: person.name, category: .people, confidence: person.confidence, isAutoGenerated: true))
        }

        // Count people
        let peopleCount = objects.filter { $0.identifier.lowercased().contains("person") }.count
        if peopleCount == 1 {
            tags.append(SmartTag(name: "Single Person", category: .people, confidence: 0.9, isAutoGenerated: true))
        } else if peopleCount > 1 {
            tags.append(SmartTag(name: "Group", category: .people, confidence: 0.9, isAutoGenerated: true))
        }

        return tags
    }

    // MARK: - Style Tags

    private func generateStyleTags(
        colors: [DominantColor],
        purpose: ImagePurpose
    ) -> [SmartTag] {
        var tags: [SmartTag] = []

        guard !colors.isEmpty else {
            return tags
        }

        // Color-based style tags
        let avgSaturation = calculateAverageSaturation(colors)
        let avgBrightness = calculateAverageBrightness(colors)

        if avgSaturation > 0.6 {
            tags.append(SmartTag(name: "Vibrant", category: .style, confidence: 0.8, isAutoGenerated: true))
        } else if avgSaturation < 0.2 {
            tags.append(SmartTag(name: "Muted", category: .style, confidence: 0.8, isAutoGenerated: true))
        }

        if avgBrightness > 0.7 {
            tags.append(SmartTag(name: "Bright", category: .style, confidence: 0.8, isAutoGenerated: true))
        } else if avgBrightness < 0.3 {
            tags.append(SmartTag(name: "Dark", category: .style, confidence: 0.8, isAutoGenerated: true))
        }

        // Purpose-based style
        if purpose == .portrait {
            tags.append(SmartTag(name: "Professional", category: .style, confidence: 0.75, isAutoGenerated: true))
        }

        return tags
    }

    // MARK: - Activity Tags

    private func generateActivityTags(
        objects: [DetectedObject],
        enhancedVision: EnhancedVisionResult?
    ) -> [SmartTag] {
        var tags: [SmartTag] = []

        // Use body pose detection for activity inference
        if let bodyPose = enhancedVision?.bodyPose,
           let activity = bodyPose.detectedActivity,
           !activity.isEmpty && activity != "unknown" {
            // Map detected activities to user-friendly tags
            let activityTag = mapActivityToTag(activity)
            if !activityTag.isEmpty {
                tags.append(SmartTag(name: activityTag, category: .content, confidence: 0.75, isAutoGenerated: true))
            }
        }

        // Infer activities from detected objects
        let objectActivities = inferActivitiesFromObjects(objects)
        for (activity, confidence) in objectActivities {
            tags.append(SmartTag(name: activity, category: .content, confidence: confidence, isAutoGenerated: true))
        }

        // Infer event type from multiple signals
        if let eventTag = inferEventType(objects: objects, enhancedVision: enhancedVision) {
            tags.append(SmartTag(name: eventTag, category: .content, confidence: 0.7, isAutoGenerated: true))
        }

        return tags
    }

    /// Map body pose activity to user-friendly tag
    private func mapActivityToTag(_ activity: String) -> String {
        let activityMap: [String: String] = [
            "sitting": "Seated",
            "standing": "Standing",
            "walking": "Walking",
            "running": "Running",
            "jumping": "Active",
            "dancing": "Dancing",
            "exercising": "Fitness",
            "yoga": "Yoga",
            "stretching": "Exercise",
            "waving": "Greeting",
            "pointing": "Gesturing"
        ]
        return activityMap[activity.lowercased()] ?? ""
    }

    /// Infer activities from detected objects using whole-word matching
    /// This fixes the issue where "ball" matched "eyeball", "crystal ball", etc.
    private func inferActivitiesFromObjects(_ objects: [DetectedObject]) -> [(String, Double)] {
        var activities: [(String, Double)] = []

        let objectIds = objects.map { $0.identifier.lowercased() }

        // Helper for whole-word matching to avoid false positives like "eyeball" matching "ball"
        func containsWholeWord(_ text: String, _ word: String) -> Bool {
            let pattern = "\\b\(NSRegularExpression.escapedPattern(for: word))\\b"
            return text.range(of: pattern, options: .regularExpression) != nil
        }

        // Helper to check if any object matches any of the target words (whole word)
        func objectsContainAny(_ targets: [String]) -> Bool {
            return objectIds.contains { objId in
                targets.contains { target in
                    // Use whole-word matching for short generic words, substring for compound words
                    if target.count <= 4 {
                        return containsWholeWord(objId, target)
                    } else {
                        return objId.contains(target) || objId == target
                    }
                }
            }
        }

        // Sports equipment -> Sports activity
        // Use specific compound words to avoid "ball" matching "eyeball", "crystal ball"
        let sportsObjects = [
            "tennis racket", "racket", "baseball bat",
            "golf club", "golf ball", "tennis ball",
            "basketball", "football", "soccer ball", "volleyball",
            "hockey stick", "badminton"
        ]
        if objectsContainAny(sportsObjects) {
            activities.append(("Sports", 0.75))
        }

        // Laptop/computer -> Working
        // "keyboard" alone is too broad (musical keyboard), require context
        let workObjects = ["laptop", "computer", "desktop", "monitor with keyboard"]
        if objectsContainAny(workObjects) {
            activities.append(("Working", 0.7))
        }
        // Keyboard only suggests working if there's also a desk/office context
        if objectIds.contains(where: { $0.contains("keyboard") }) &&
           objectIds.contains(where: { $0.contains("desk") || $0.contains("office") || $0.contains("laptop") }) {
            if !activities.contains(where: { $0.0 == "Working" }) {
                activities.append(("Working", 0.65))
            }
        }

        // Musical instruments -> Music
        let musicObjects = ["guitar", "piano", "violin", "drums", "drum kit", "microphone stand", "saxophone", "trumpet"]
        if objectsContainAny(musicObjects) {
            activities.append(("Music", 0.75))
        }

        // Camera equipment -> Photography
        let photoObjects = ["camera", "tripod", "dslr", "lens"]
        if objectsContainAny(photoObjects) {
            activities.append(("Photography", 0.7))
        }

        // Cooking/kitchen items -> Cooking
        // More specific to avoid false positives
        let cookingObjects = ["frying pan", "saucepan", "stove", "oven", "cutting board", "chef knife", "spatula", "whisk"]
        if objectsContainAny(cookingObjects) {
            activities.append(("Cooking", 0.7))
        }

        // Books/reading -> Reading
        // Be specific about reading materials
        let readingObjects = ["book", "textbook", "magazine", "newspaper", "e-reader", "kindle"]
        if objectsContainAny(readingObjects) {
            activities.append(("Reading", 0.7))
        }

        return activities
    }

    /// Infer event type from objects and enhanced vision
    private func inferEventType(objects: [DetectedObject], enhancedVision: EnhancedVisionResult?) -> String? {
        let objectIds = objects.map { $0.identifier.lowercased() }

        // Count people/faces for group event detection
        let peopleCount = objects.filter { obj in
            let id = obj.identifier.lowercased()
            return id.contains("person") || id.contains("people") || id.contains("human")
        }.count

        let faceCount = objects.filter { obj in
            obj.identifier.lowercased().contains("face")
        }.count

        let totalPeople = max(peopleCount, faceCount)

        // Party/celebration indicators
        let partyObjects = ["cake", "balloon", "candle", "champagne", "wine", "cocktail"]
        let partyCount = objectIds.filter { id in partyObjects.contains(where: { id.contains($0) }) }.count

        // Celebration: party objects + people
        if partyCount >= 2 || (partyCount >= 1 && totalPeople >= 2) {
            return "Celebration"
        }

        // Wedding indicators
        if objectIds.contains(where: { $0.contains("wedding") || $0.contains("bride") || $0.contains("groom") }) {
            return "Wedding"
        }

        // Beach/vacation indicators
        let beachObjects = ["beach", "sand", "umbrella", "sunglasses", "swimsuit"]
        let beachCount = objectIds.filter { id in beachObjects.contains(where: { id.contains($0) }) }.count
        if beachCount >= 2 {
            return "Vacation"
        }

        // Group/meeting detection based on people count
        if totalPeople >= 4 {
            // Check for formal setting indicators
            let formalObjects = ["table", "chair", "laptop", "presentation", "whiteboard", "conference"]
            let hasFormalSetting = objectIds.contains { id in
                formalObjects.contains(where: { id.contains($0) })
            }
            if hasFormalSetting {
                return "Meeting"
            }
            return "Group Event"
        } else if totalPeople >= 2 {
            // Smaller gatherings
            let diningObjects = ["table", "plate", "glass", "food", "restaurant"]
            let hasDiningSetting = objectIds.contains { id in
                diningObjects.contains(where: { id.contains($0) })
            }
            if hasDiningSetting {
                return "Gathering"
            }
        }

        return nil
    }

    // MARK: - Use Case Tags

    private func generateUseCaseTags(
        purpose: ImagePurpose,
        objects: [DetectedObject],
        quality: ImageQuality,
        megapixels: Double
    ) -> [SmartTag] {
        var tags: [SmartTag] = []

        // Quality-gated use case suggestions
        // Only suggest professional use cases for high-quality images
        let isHighQuality = quality == .high
        let isHighResolution = megapixels >= 8.0  // 8MP or higher

        switch purpose {
        case .portrait:
            // Social Media works for most quality levels
            tags.append(SmartTag(name: "Social Media", category: .useCase, confidence: 0.8, isAutoGenerated: true))
            // Profile Picture only for quality portraits
            if isHighQuality {
                tags.append(SmartTag(name: "Profile Picture", category: .useCase, confidence: 0.75, isAutoGenerated: true))
            }

        case .landscape:
            // Travel works for most landscapes
            tags.append(SmartTag(name: "Travel", category: .useCase, confidence: 0.75, isAutoGenerated: true))
            // Wallpaper only for high-resolution landscapes
            if isHighResolution && isHighQuality {
                tags.append(SmartTag(name: "Wallpaper", category: .useCase, confidence: 0.8, isAutoGenerated: true))
            }

        case .food:
            tags.append(SmartTag(name: "Recipe", category: .useCase, confidence: 0.8, isAutoGenerated: true))
            // Menu only for appetizing (quality) food photos
            if isHighQuality {
                tags.append(SmartTag(name: "Menu", category: .useCase, confidence: 0.7, isAutoGenerated: true))
            }

        case .document, .screenshot:
            tags.append(SmartTag(name: "Reference", category: .useCase, confidence: 0.85, isAutoGenerated: true))
            tags.append(SmartTag(name: "Documentation", category: .useCase, confidence: 0.8, isAutoGenerated: true))

        case .productPhoto:
            // E-commerce only for professional quality product shots
            if isHighQuality {
                tags.append(SmartTag(name: "E-commerce", category: .useCase, confidence: 0.85, isAutoGenerated: true))
            } else {
                tags.append(SmartTag(name: "Product Reference", category: .useCase, confidence: 0.7, isAutoGenerated: true))
            }

        case .groupPhoto:
            tags.append(SmartTag(name: "Social Media", category: .useCase, confidence: 0.75, isAutoGenerated: true))
            tags.append(SmartTag(name: "Memories", category: .useCase, confidence: 0.8, isAutoGenerated: true))

        default:
            // Add generic fallback for unknown purposes
            tags.append(SmartTag(name: "Personal Archive", category: .useCase, confidence: 0.6, isAutoGenerated: true))
        }

        return tags
    }

    // MARK: - Helper Methods

    private func purposeToTag(_ purpose: ImagePurpose) -> String {
        switch purpose {
        case .portrait: return "Portrait"
        case .groupPhoto: return "Group Photo"
        case .landscape: return "Landscape"
        case .architecture: return "Architecture"
        case .wildlife: return "Wildlife"
        case .food: return "Food"
        case .document: return "Document"
        case .screenshot: return "Screenshot"
        case .productPhoto: return "Product"
        case .general: return "General"
        }
    }

    private func calculateAverageSaturation(_ colors: [DominantColor]) -> CGFloat {
        let saturations = colors.prefix(3).map { color -> CGFloat in
            let rgb = color.color.usingColorSpace(.deviceRGB) ?? color.color
            return rgb.saturationComponent
        }
        return saturations.reduce(0, +) / CGFloat(saturations.count)
    }

    private func calculateAverageBrightness(_ colors: [DominantColor]) -> CGFloat {
        let brightnesses = colors.prefix(3).map { color -> CGFloat in
            let rgb = color.color.usingColorSpace(.deviceRGB) ?? color.color
            return rgb.brightnessComponent
        }
        return brightnesses.reduce(0, +) / CGFloat(brightnesses.count)
    }

    private func deduplicateAndLimit(_ tags: [SmartTag], limit: Int) -> [SmartTag] {
        var uniqueTags: [SmartTag] = []
        var seenNames = Set<String>()

        // Define semantic equivalents - more specific terms should exclude generic ones
        let semanticEquivalents: [String: Set<String>] = [
            "portrait": ["person", "single person", "face", "people"],
            "group photo": ["people", "group", "person"],
            "landscape": ["outdoor", "nature", "outdoors"],
            "food": ["meal", "dish", "recipe"],
            "single person": ["person"],
            "group": ["people"]
        ]

        for tag in tags.sorted(by: { $0.confidence > $1.confidence }) {
            let lowercasedName = tag.name.lowercased()

            // Skip if exact name already seen
            if seenNames.contains(lowercasedName) {
                continue
            }

            // Skip if a semantic equivalent (more specific) is already present
            var shouldSkip = false
            for (specific, generics) in semanticEquivalents {
                if seenNames.contains(specific) && generics.contains(lowercasedName) {
                    // A more specific tag exists, skip this generic one
                    shouldSkip = true
                    break
                }
            }

            if shouldSkip {
                continue
            }

            uniqueTags.append(tag)
            seenNames.insert(lowercasedName)

            if uniqueTags.count >= limit {
                break
            }
        }

        return uniqueTags
    }
}
