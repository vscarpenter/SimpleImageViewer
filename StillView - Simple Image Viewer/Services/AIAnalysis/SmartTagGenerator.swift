import Foundation

/// Generates hierarchical, searchable smart tags for images
/// Categorizes tags by: Content (WHAT), Location (WHERE), Time (WHEN), People (WHO), Style, and Use Case
final class SmartTagGenerator {

    // MARK: - Public Interface

    func generateSmartTags(
        classifications: [ClassificationResult],
        objects: [DetectedObject],
        scenes: [SceneClassification],
        text: [RecognizedText],
        colors: [DominantColor],
        landmarks: [DetectedLandmark],
        recognizedPeople: [RecognizedPerson],
        purpose: ImagePurpose,
        quality: ImageQuality = .unknown,
        megapixels: Double = 0,
        enhancedVision: EnhancedVisionResult? = nil
    ) -> [SmartTag] {
        var tags: [SmartTag] = []

        // Generate tags by category
        tags.append(contentsOf: generateContentTags(classifications: classifications, objects: objects, purpose: purpose))
        tags.append(contentsOf: generateLocationTags(scenes: scenes, landmarks: landmarks, purpose: purpose))
        tags.append(contentsOf: generateTimeTags(colors: colors, scenes: scenes))
        tags.append(contentsOf: generatePeopleTags(objects: objects, recognizedPeople: recognizedPeople))
        tags.append(contentsOf: generateStyleTags(colors: colors, purpose: purpose))
        tags.append(contentsOf: generateActivityTags(objects: objects, enhancedVision: enhancedVision))
        tags.append(contentsOf: generateUseCaseTags(purpose: purpose, objects: objects, quality: quality, megapixels: megapixels))

        // Remove duplicates and return top 12
        return deduplicateAndLimit(tags, limit: 12)
    }

    // MARK: - Content Tags (WHAT)

    private func generateContentTags(
        classifications: [ClassificationResult],
        objects: [DetectedObject],
        purpose: ImagePurpose
    ) -> [SmartTag] {
        var tags: [SmartTag] = []

        // Add purpose-specific tag
        let purposeTag = purposeToTag(purpose)
        tags.append(SmartTag(name: purposeTag, category: .content, confidence: 0.95, isAutoGenerated: true))

        // Add top objects
        for object in objects.prefix(3) {
            let name = object.identifier.replacingOccurrences(of: "_", with: " ").capitalized
            tags.append(SmartTag(name: name, category: .content, confidence: Double(object.confidence), isAutoGenerated: true))
        }

        // Add top classifications (skip generic terms)
        for classification in classifications.prefix(3) {
            if !AIAnalysisConstants.isGeneric(classification.identifier) {
                let name = classification.identifier.replacingOccurrences(of: "_", with: " ").capitalized
                tags.append(SmartTag(name: name, category: .content, confidence: Double(classification.confidence), isAutoGenerated: true))
            }
        }

        return tags
    }

    // MARK: - Location Tags (WHERE)

    private func generateLocationTags(
        scenes: [SceneClassification],
        landmarks: [DetectedLandmark],
        purpose: ImagePurpose
    ) -> [SmartTag] {
        var tags: [SmartTag] = []

        // Add landmarks
        for landmark in landmarks.prefix(2) {
            tags.append(SmartTag(name: landmark.name, category: .location, confidence: landmark.confidence, isAutoGenerated: true))
        }

        // Add scene-based location tags
        for scene in scenes.prefix(2) {
            let id = scene.identifier.lowercased()

            if id.contains("outdoor") {
                tags.append(SmartTag(name: "Outdoor", category: .location, confidence: Double(scene.confidence), isAutoGenerated: true))
            } else if id.contains("indoor") {
                tags.append(SmartTag(name: "Indoor", category: .location, confidence: Double(scene.confidence), isAutoGenerated: true))
            }

            if id.contains("nature") || id.contains("forest") || id.contains("mountain") {
                tags.append(SmartTag(name: "Nature", category: .location, confidence: Double(scene.confidence), isAutoGenerated: true))
            } else if id.contains("urban") || id.contains("city") {
                tags.append(SmartTag(name: "Urban", category: .location, confidence: Double(scene.confidence), isAutoGenerated: true))
            }
        }

        return tags
    }

    // MARK: - Time Tags (WHEN)

    private func generateTimeTags(
        colors: [DominantColor],
        scenes: [SceneClassification]
    ) -> [SmartTag] {
        var tags: [SmartTag] = []

        guard let dominantColor = colors.first else {
            return tags
        }

        let rgb = dominantColor.color.usingColorSpace(.deviceRGB) ?? dominantColor.color
        let brightness = rgb.brightnessComponent

        // Time of day based on brightness
        if brightness > 0.7 {
            tags.append(SmartTag(name: "Daytime", category: .time, confidence: 0.7, isAutoGenerated: true))
        } else if brightness < 0.3 {
            tags.append(SmartTag(name: "Night", category: .time, confidence: 0.7, isAutoGenerated: true))
        }

        // Lighting conditions
        if scenes.contains(where: { $0.identifier.lowercased().contains("sunset") }) {
            tags.append(SmartTag(name: "Sunset", category: .time, confidence: 0.8, isAutoGenerated: true))
        } else if scenes.contains(where: { $0.identifier.lowercased().contains("sunrise") }) {
            tags.append(SmartTag(name: "Sunrise", category: .time, confidence: 0.8, isAutoGenerated: true))
        }

        return tags
    }

    // MARK: - People Tags (WHO)

    private func generatePeopleTags(
        objects: [DetectedObject],
        recognizedPeople: [RecognizedPerson]
    ) -> [SmartTag] {
        var tags: [SmartTag] = []

        // Add recognized people
        for person in recognizedPeople {
            tags.append(SmartTag(name: person.name, category: .people, confidence: person.confidence, isAutoGenerated: true))
        }

        // Count people
        let peopleCount = objects.filter { $0.identifier.lowercased().contains("person") }.count
        if peopleCount == 1 {
            tags.append(SmartTag(name: "Single Person", category: .people, confidence: 0.9, isAutoGenerated: true))
        } else if peopleCount > 1 {
            tags.append(SmartTag(name: "Group", category: .people, confidence: 0.9, isAutoGenerated: true))
        }

        return tags
    }

    // MARK: - Style Tags

    private func generateStyleTags(
        colors: [DominantColor],
        purpose: ImagePurpose
    ) -> [SmartTag] {
        var tags: [SmartTag] = []

        guard !colors.isEmpty else {
            return tags
        }

        // Color-based style tags
        let avgSaturation = calculateAverageSaturation(colors)
        let avgBrightness = calculateAverageBrightness(colors)

        if avgSaturation > 0.6 {
            tags.append(SmartTag(name: "Vibrant", category: .style, confidence: 0.8, isAutoGenerated: true))
        } else if avgSaturation < 0.2 {
            tags.append(SmartTag(name: "Muted", category: .style, confidence: 0.8, isAutoGenerated: true))
        }

        if avgBrightness > 0.7 {
            tags.append(SmartTag(name: "Bright", category: .style, confidence: 0.8, isAutoGenerated: true))
        } else if avgBrightness < 0.3 {
            tags.append(SmartTag(name: "Dark", category: .style, confidence: 0.8, isAutoGenerated: true))
        }

        // Purpose-based style
        if purpose == .portrait {
            tags.append(SmartTag(name: "Professional", category: .style, confidence: 0.75, isAutoGenerated: true))
        }

        return tags
    }

    // MARK: - Activity Tags

    private func generateActivityTags(
        objects: [DetectedObject],
        enhancedVision: EnhancedVisionResult?
    ) -> [SmartTag] {
        var tags: [SmartTag] = []

        // Use body pose detection for activity inference
        if let bodyPose = enhancedVision?.bodyPose,
           let activity = bodyPose.detectedActivity,
           !activity.isEmpty && activity != "unknown" {
            // Map detected activities to user-friendly tags
            let activityTag = mapActivityToTag(activity)
            if !activityTag.isEmpty {
                tags.append(SmartTag(name: activityTag, category: .content, confidence: 0.75, isAutoGenerated: true))
            }
        }

        // Infer activities from detected objects
        let objectActivities = inferActivitiesFromObjects(objects)
        for (activity, confidence) in objectActivities {
            tags.append(SmartTag(name: activity, category: .content, confidence: confidence, isAutoGenerated: true))
        }

        // Infer event type from multiple signals
        if let eventTag = inferEventType(objects: objects, enhancedVision: enhancedVision) {
            tags.append(SmartTag(name: eventTag, category: .content, confidence: 0.7, isAutoGenerated: true))
        }

        return tags
    }

    /// Map body pose activity to user-friendly tag
    private func mapActivityToTag(_ activity: String) -> String {
        let activityMap: [String: String] = [
            "sitting": "Seated",
            "standing": "Standing",
            "walking": "Walking",
            "running": "Running",
            "jumping": "Active",
            "dancing": "Dancing",
            "exercising": "Fitness",
            "yoga": "Yoga",
            "stretching": "Exercise",
            "waving": "Greeting",
            "pointing": "Gesturing"
        ]
        return activityMap[activity.lowercased()] ?? ""
    }

    /// Infer activities from detected objects
    private func inferActivitiesFromObjects(_ objects: [DetectedObject]) -> [(String, Double)] {
        var activities: [(String, Double)] = []

        let objectIds = objects.map { $0.identifier.lowercased() }

        // Sports equipment -> Sports activity
        let sportsObjects = ["ball", "racket", "bat", "golf", "tennis", "basketball", "football", "soccer"]
        if objectIds.contains(where: { id in sportsObjects.contains(where: { id.contains($0) }) }) {
            activities.append(("Sports", 0.75))
        }

        // Laptop/computer -> Working
        if objectIds.contains(where: { $0.contains("laptop") || $0.contains("computer") || $0.contains("keyboard") }) {
            activities.append(("Working", 0.7))
        }

        // Musical instruments -> Music
        let musicObjects = ["guitar", "piano", "violin", "drums", "microphone"]
        if objectIds.contains(where: { id in musicObjects.contains(where: { id.contains($0) }) }) {
            activities.append(("Music", 0.75))
        }

        // Camera equipment -> Photography
        if objectIds.contains(where: { $0.contains("camera") || $0.contains("tripod") }) {
            activities.append(("Photography", 0.7))
        }

        // Cooking/kitchen items -> Cooking
        let cookingObjects = ["pan", "pot", "stove", "oven", "cutting board", "knife"]
        if objectIds.contains(where: { id in cookingObjects.contains(where: { id.contains($0) }) }) {
            activities.append(("Cooking", 0.7))
        }

        // Books/reading -> Reading
        if objectIds.contains(where: { $0.contains("book") || $0.contains("magazine") || $0.contains("newspaper") }) {
            activities.append(("Reading", 0.7))
        }

        return activities
    }

    /// Infer event type from objects and enhanced vision
    private func inferEventType(objects: [DetectedObject], enhancedVision: EnhancedVisionResult?) -> String? {
        let objectIds = objects.map { $0.identifier.lowercased() }

        // Party/celebration indicators
        let partyObjects = ["cake", "balloon", "candle", "champagne", "wine", "cocktail"]
        let partyCount = objectIds.filter { id in partyObjects.contains(where: { id.contains($0) }) }.count
        if partyCount >= 2 {
            return "Celebration"
        }

        // Wedding indicators
        if objectIds.contains(where: { $0.contains("wedding") || $0.contains("bride") || $0.contains("groom") }) {
            return "Wedding"
        }

        // Beach/vacation indicators
        let beachObjects = ["beach", "sand", "umbrella", "sunglasses", "swimsuit"]
        let beachCount = objectIds.filter { id in beachObjects.contains(where: { id.contains($0) }) }.count
        if beachCount >= 2 {
            return "Vacation"
        }

        // Meeting indicators (multiple people + formal setting objects)
        if let faceCount = enhancedVision?.animals, faceCount.isEmpty == false {
            // This is a placeholder - in real implementation, check for multiple faces
        }

        return nil
    }

    // MARK: - Use Case Tags

    private func generateUseCaseTags(
        purpose: ImagePurpose,
        objects: [DetectedObject],
        quality: ImageQuality,
        megapixels: Double
    ) -> [SmartTag] {
        var tags: [SmartTag] = []

        // Quality-gated use case suggestions
        // Only suggest professional use cases for high-quality images
        let isHighQuality = quality == .high
        let isHighResolution = megapixels >= 8.0  // 8MP or higher

        switch purpose {
        case .portrait:
            // Social Media works for most quality levels
            tags.append(SmartTag(name: "Social Media", category: .useCase, confidence: 0.8, isAutoGenerated: true))
            // Profile Picture only for quality portraits
            if isHighQuality {
                tags.append(SmartTag(name: "Profile Picture", category: .useCase, confidence: 0.75, isAutoGenerated: true))
            }

        case .landscape:
            // Travel works for most landscapes
            tags.append(SmartTag(name: "Travel", category: .useCase, confidence: 0.75, isAutoGenerated: true))
            // Wallpaper only for high-resolution landscapes
            if isHighResolution && isHighQuality {
                tags.append(SmartTag(name: "Wallpaper", category: .useCase, confidence: 0.8, isAutoGenerated: true))
            }

        case .food:
            tags.append(SmartTag(name: "Recipe", category: .useCase, confidence: 0.8, isAutoGenerated: true))
            // Menu only for appetizing (quality) food photos
            if isHighQuality {
                tags.append(SmartTag(name: "Menu", category: .useCase, confidence: 0.7, isAutoGenerated: true))
            }

        case .document, .screenshot:
            tags.append(SmartTag(name: "Reference", category: .useCase, confidence: 0.85, isAutoGenerated: true))
            tags.append(SmartTag(name: "Documentation", category: .useCase, confidence: 0.8, isAutoGenerated: true))

        case .productPhoto:
            // E-commerce only for professional quality product shots
            if isHighQuality {
                tags.append(SmartTag(name: "E-commerce", category: .useCase, confidence: 0.85, isAutoGenerated: true))
            } else {
                tags.append(SmartTag(name: "Product Reference", category: .useCase, confidence: 0.7, isAutoGenerated: true))
            }

        case .groupPhoto:
            tags.append(SmartTag(name: "Social Media", category: .useCase, confidence: 0.75, isAutoGenerated: true))
            tags.append(SmartTag(name: "Memories", category: .useCase, confidence: 0.8, isAutoGenerated: true))

        default:
            // Add generic fallback for unknown purposes
            tags.append(SmartTag(name: "Personal Archive", category: .useCase, confidence: 0.6, isAutoGenerated: true))
        }

        return tags
    }

    // MARK: - Helper Methods

    private func purposeToTag(_ purpose: ImagePurpose) -> String {
        switch purpose {
        case .portrait: return "Portrait"
        case .groupPhoto: return "Group Photo"
        case .landscape: return "Landscape"
        case .architecture: return "Architecture"
        case .wildlife: return "Wildlife"
        case .food: return "Food"
        case .document: return "Document"
        case .screenshot: return "Screenshot"
        case .productPhoto: return "Product"
        case .general: return "General"
        }
    }

    private func calculateAverageSaturation(_ colors: [DominantColor]) -> CGFloat {
        let saturations = colors.prefix(3).map { color -> CGFloat in
            let rgb = color.color.usingColorSpace(.deviceRGB) ?? color.color
            return rgb.saturationComponent
        }
        return saturations.reduce(0, +) / CGFloat(saturations.count)
    }

    private func calculateAverageBrightness(_ colors: [DominantColor]) -> CGFloat {
        let brightnesses = colors.prefix(3).map { color -> CGFloat in
            let rgb = color.color.usingColorSpace(.deviceRGB) ?? color.color
            return rgb.brightnessComponent
        }
        return brightnesses.reduce(0, +) / CGFloat(brightnesses.count)
    }

    private func deduplicateAndLimit(_ tags: [SmartTag], limit: Int) -> [SmartTag] {
        var uniqueTags: [SmartTag] = []
        var seenNames = Set<String>()

        // Define semantic equivalents - more specific terms should exclude generic ones
        let semanticEquivalents: [String: Set<String>] = [
            "portrait": ["person", "single person", "face", "people"],
            "group photo": ["people", "group", "person"],
            "landscape": ["outdoor", "nature", "outdoors"],
            "food": ["meal", "dish", "recipe"],
            "single person": ["person"],
            "group": ["people"]
        ]

        for tag in tags.sorted(by: { $0.confidence > $1.confidence }) {
            let lowercasedName = tag.name.lowercased()

            // Skip if exact name already seen
            if seenNames.contains(lowercasedName) {
                continue
            }

            // Skip if a semantic equivalent (more specific) is already present
            var shouldSkip = false
            for (specific, generics) in semanticEquivalents {
                if seenNames.contains(specific) && generics.contains(lowercasedName) {
                    // A more specific tag exists, skip this generic one
                    shouldSkip = true
                    break
                }
            }

            if shouldSkip {
                continue
            }

            uniqueTags.append(tag)
            seenNames.insert(lowercasedName)

            if uniqueTags.count >= limit {
                break
            }
        }

        return uniqueTags
    }
}
